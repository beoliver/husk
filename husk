#!/usr/bin/env python3

import argparse
import json
import os
import re
import sqlite3
import sys
from pathlib import Path

HUSK_DIR = ".husk"
CONFIG_HUSK_DIR = "husk"
CONFIG_FILE = "config.json"
HUSK_DB = "husk.db"
DB_ENV_VAR = "HUSK_DB"
HUSK_CONTEXT_FILENAME = ".husk_context"
DEFAULT_HUSK_CONTEXT = "HUSK"

# context types -----------------------------------------------------------------

VIRTUAL_CONTEXT_TYPE = "VIRTUAL"
FILE_CONTEXT_TYPE = "FILE"

# husk context -------------------------------------------------------------------

# The path the database that we use is controlled by the user.
# We have to read `$HOME/.config/husk/config.json` every time.
# It would be nice if we could use a python `context`
# which would let us write something like

# with Husk() as husk:
#     print(husk.config)
#     cursor = husk.conn.cursor()
#     cursor.execute("INERT INTO contexts VALUES ...")

# and then `conn` is closed by `Husk()`


class Husk(object):
    def __init__(self):
        config_path = os.path.join(
            str(Path.home()), ".config", CONFIG_HUSK_DIR, CONFIG_FILE
        )
        with open(config_path) as config:
            self.config = json.loads(config.read())

    def __enter__(self):
        self.conn = sqlite3.connect(self.config["db_path"])
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self.conn.close()


# sqlite3 initialization ---------------------------------------------------------

# In order to use the husk program, a user must have an instance of a sqlite database


def initialize_husk_config(config_dir, db_path, force=False):
    config_path = Path(config_dir)
    if not config_path.exists():
        config_path.mkdir()
    husk_config_path = Path(os.path.join(config_dir, CONFIG_HUSK_DIR))
    husk_config_path.mkdir(exist_ok=force)
    with open(os.path.join(str(husk_config_path), CONFIG_FILE), "w+") as f:
        f.write(json.dumps({"db_path": db_path}))


def initialize_husk_db(db_path, force=False):
    Path(os.path.dirname(db_path)).mkdir(exist_ok=force)
    Path(db_path).touch()
    os.remove(db_path)
    Path(db_path).touch()
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute(
        """CREATE TABLE contexts 
           (context_id INTEGER PRIMARY KEY AUTOINCREMENT, 
           context_name TEXT NOT NULL UNIQUE, 
           context_type TEXT NOT NULL,           
           context_path TEXT UNIQUE,
           created_at DATETIME DEFAULT CURRENT_TIMESTAMP);"""
    )
    cur.execute(
        "INSERT INTO contexts (context_name, context_path, context_type) VALUES (?,?,?)",
        (DEFAULT_HUSK_CONTEXT, None, VIRTUAL_CONTEXT_TYPE),
    )
    cur.execute(
        """CREATE TABLE tags 
           (tag_id INTEGER PRIMARY KEY AUTOINCREMENT, 
           tag_name TEXT NOT NULL UNIQUE, 
           created_at DATETIME DEFAULT CURRENT_TIMESTAMP);"""
    )
    cur.execute(
        """CREATE TABLE context_tags 
           (context_id INTEGER NOT NULL, 
           tag_id INTEGER NOT NULL, 
           created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
           FOREIGN KEY (context_id) REFERENCES contexts (context_id), 
           FOREIGN KEY (tag_id) REFERENCES contexts (tag_id), 
           UNIQUE(context_id, tag_id));"""
    )
    conn.commit()
    conn.close()


def infer_context_from_invocation_path(path):
    """
    walk up the path looking for a file with the 
    name $HUSK_CONTEXT_FILENAME.    
    """
    while True:
        (next_path, _) = os.path.split(path)
        with os.scandir(path) as dir:
            file = next(
                filter(
                    lambda entry: entry.is_file()
                    and entry.name == HUSK_CONTEXT_FILENAME,
                    dir,
                ),
                None,
            )
        if file:
            with open(file.path, "r") as f:
                data = f.read()
            context_info = json.loads(data)
            return context_info
        else:
            if path == next_path:
                return None
            else:
                path = next_path


# argparse -------------------------------------------------------------------------

INIT_COMMAND = "init"
CONTEXT_COMMAND = "ctx"
CONTEXT_INIT_COMMAND = "{} {}".format(CONTEXT_COMMAND, INIT_COMMAND)
LIST_COMMAND = "list"
CONTEXT_LIST_COMMAND = "{} {}".format(CONTEXT_COMMAND, LIST_COMMAND)

# SAVE_COMMAND = "save"
# FIND_COMMAND = "find"
# LIST_COMMAND = "list"
# TAGS_COMMAND = "tags"

arg_parser = argparse.ArgumentParser(
    prog="hu",
    description="husk is a command line application for taking notes in context.",
)

subparsers = arg_parser.add_subparsers()

init_parser = subparsers.add_parser(
    INIT_COMMAND,
    help="Initialize a new database",
    description="Initialize a new database",
)

init_parser.set_defaults(command=INIT_COMMAND)

init_parser.add_argument(
    "-f",
    "--force",
    action="store_true",
    help="Use force. This will overwrite any existing databases and configurations",
)

init_parser.add_argument(
    "--path",
    metavar="PATH",
    default=os.path.join(str(Path.home()), HUSK_DIR),
    type=str,
    help="Dir to create the {} dir containing the database. Defaults to $HOME".format(
        HUSK_DIR
    ),
)

# CONTEXT parser ------------------------------------------------------------------------

context_parser = subparsers.add_parser(
    CONTEXT_COMMAND, help="Context stuff", description="Context stuff",
)

context_parser.set_defaults(command=CONTEXT_COMMAND)

context_subparsers = context_parser.add_subparsers()

# CONTEXT INIT parser --------------------------------------------------------------

context_init_parser = context_subparsers.add_parser(
    INIT_COMMAND, help="Initiate a new context", description="Initiate a new context",
)

context_init_parser.set_defaults(command=CONTEXT_INIT_COMMAND)

context_init_parser.add_argument(
    "--virtual",
    action="store_true",
    help="Create a virtual context that is not tied to your filesystem.",
)

context_init_parser.add_argument(
    "--name",
    type=str,
    default=os.path.basename(os.getcwd()),
    help="Name of the context. By default the name of the current working diretory",
)

context_init_parser.add_argument(
    "--path",
    metavar="PATH",
    default=os.getcwd(),
    type=str,
    help="Path to context root directory. By default the path to the current working directory. This flag is ignored when creating a virtual context.",
)

# CONTEXT LIST parser --------------------------------------------------------------

context_list_parser = context_subparsers.add_parser(
    LIST_COMMAND, help="List all contexts", description="List all contexts",
)

context_list_parser.add_argument(
    "-G", action="store_true", help="All contexts",
)

context_list_parser.add_argument(
    "-a", action="store_true", help="Include anscestors",
)

context_list_parser.add_argument(
    "-d", action="store_true", help="Include descendents",
)

context_list_parser.add_argument(
    "--name",
    type=str,
    default=infer_context_from_invocation_path(os.getcwd()),
    help="Name of the context",
)

context_list_parser.set_defaults(command=CONTEXT_LIST_COMMAND)


# helpers  -------------------------------------------------------------------------


def should_continue(input):
    return input.lower() == "y"


def user_confirmation(message, implicit_yes=False):
    if implicit_yes:
        return implicit_yes
    selection = input("{}\nProceed? [y/N]: ".format(message))
    return should_continue(selection)


# handlers -------------------------------------------------------------------------


def save_handler(db, args):
    item = args.input
    tags = args.tags
    print("save!", item, "as", tags)


def find_handler(db, args):
    print("find!")


# init handler ---------------------------------------------------------------------


def init_handler(args):
    force = args.force
    db_location = os.path.join(args.path, HUSK_DB)
    config_path = os.path.join(str(Path.home()), ".config")

    message = "This will perform the following actions:\n1. Create '{}'.\n2. Create a directory '{}' in '{}'.".format(
        db_location, CONFIG_HUSK_DIR, config_path,
    )

    if user_confirmation(message, force):
        initialize_husk_db(db_location, force=force)
        initialize_husk_config(config_path, db_location, force=force)


# context init handler -------------------------------------------------------------


def context_init_handler(args):
    context_name = args.name
    context_path = args.path
    context_type = VIRTUAL_CONTEXT_TYPE if args.virtual else FILE_CONTEXT_TYPE
    with Husk() as husk:
        husk.conn.execute(
            "INSERT INTO contexts (context_name, context_path, context_type) VALUES (?,?,?)",
            (context_name, None if args.virtual else context_path, context_type),
        )
        husk.conn.commit()


# context list handler -------------------------------------------------------------


def context_list_handler(args):
    context_name = args.name
    # global_search = args.G

    with Husk() as husk:
        headers = [
            "context_name",
            "context_type",
            "created_at",
            "context_path",
        ]
        base_query = "SELECT {} FROM contexts".format(",".join(headers))
        query = (
            base_query
            if context_name == None
            else "{} WHERE context_name = '{}'".format(base_query, context_name)
        )
        results = list(husk.conn.execute(query))

        # calc padding based on either 16 chars default or the longest
        # string in the column.

        padding = list(
            map(
                lambda col: max(
                    12, 1 + max(map(lambda row_item: len(str(row_item)), col))
                ),
                zip(*results),
            )
        )

        print(
            "".join(
                str(x).ljust(pad)
                for (x, pad) in zip(["CONTEXT", "TYPE", "CREATED", "PATH",], padding)
            )
        )
        print(sum(padding) * "-")
        for row in results:
            print("".join(str(x).ljust(pad) for (x, pad) in zip(row, padding)))


# tags handler ---------------------------------------------------------------------


def tags_handler(db, args):
    print("context: {}".format(args.context))
    print("TAGS!")


# list handler ---------------------------------------------------------------------


def list_tags(db, regex_pattern=None):
    tags = (tag for (tag,) in db.execute("SELECT tag FROM tags"))
    if regex_pattern is None:
        return tags
    pattern = re.compile(regex_pattern)
    return filter(lambda tag: pattern.match(tag), tags)


def list_bookmarks(db, regex_pattern=None):
    urls = (url for (url,) in db.execute("SELECT url FROM bookmarks"))
    if regex_pattern is None:
        return urls
    pattern = re.compile(regex_pattern)
    return filter(lambda url: pattern.match(url), urls)


def list_handler(db, args):
    items_to_list = args.type
    optional_regex = args.pattern
    list_handlers = {"tags": list_tags, "bookmarks": list_bookmarks}
    items = list_handlers[items_to_list](db, optional_regex)
    for item in items:
        print(item)


# handlers -------------------------------------------------------------------------
# dispatch -------------------------------------------------------------------------

command_handlers = {
    INIT_COMMAND: init_handler,
    CONTEXT_INIT_COMMAND: context_init_handler,
    CONTEXT_LIST_COMMAND: context_list_handler,
    # SAVE_COMMAND: save_handler,
    # FIND_COMMAND: find_handler,
    # LIST_COMMAND: list_handler,
    # TAGS_COMMAND: tags_handler,
}

# helpers --------------------------------------------------------------------------


def ensure_command(command):
    if command is None:
        raise Exception("No COMMAND selected...")
    return command


# main ------------------------------------------------------------------------------


def main(args):
    command = ensure_command(vars(args).get("command", None))
    command_handlers[command](args)


if __name__ == "__main__":
    args = arg_parser.parse_args()
    try:
        main(args)
    except Exception as e:
        print(e)
        sys.exit(1)
